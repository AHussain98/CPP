# include <iostream>
# include <vector>

// a child object is stored in memory as a parent object followed by the child part
//


class shape{
        public :
        virtual void draw() const {std::cout << "drawing generic shape" << std::endl;
        }
       virtual ~shape() { std::cout << "shape destoryed" << std::endl; // if we make the destructor virtual, it will be called on teh dynamic type, not the static type, and the circle object will be properly deleted
        }                  // we can also make this = default, does the same thing but just a bit more modern
};

class circle : public shape {
    public:
        void draw() const override {std::cout << "drawing a circle" << std::endl; // override here will check we're doing this correctly
        }
    ~circle(){ std::cout << "circle destroyed!" << std::endl;
    }
};

int main(){

//circle circ; // just creating a derived class like this and letting it go out of scope will call the destructors in th reverse order that teh constructors appreared
// so first is the circle destructor and then comes the shape destructor

// however, if we were to create a base pointer anc create derived objects via the pointer, this may cause the derived destructor to not be called

std::vector<shape *> shapes; // vector of pointers to shape objects
shapes.push_back(new circle); // store a circle in the vector

for (auto shape : shapes){
    shape->draw(); // call the draw function of the circle object we're pointing to
}

for (auto shape : shapes){
    delete shape; // release allocated memory
}

// now, notice only the shape destructor is called, the derived circle destructor is not called
// this is because the pointer only points to the shape part of the object in memory, not the wraparound derived class
// if the destructor is not virtual, static binding will be used (again, this only matters for references and pointers of base object type but pointing to derived objects)
// we need to use dynamic binding, just like inherited virtual functions, a virtual destructor must be used
// using a virtual destructor, the runtime knows its dealing with a cirle object and not just a shape one, so the circle destructor is called too

// if we do not define a destructor, the compiler will synthesize one for us
// the default destructor generated by the compiler is NOT virtual
// if we are going through a pointer to base, this means that the derived part of the object is not destroyed, leads to memory leaks, resource leaks and undefined behaviour
// we can prevent this by implementing a destructor and making it virtual
// we do not need to implement the other special member functions
// in general, if a class has virtual functions, it should have a virtual destructor

// also signature also includes constness, not just arguments

}